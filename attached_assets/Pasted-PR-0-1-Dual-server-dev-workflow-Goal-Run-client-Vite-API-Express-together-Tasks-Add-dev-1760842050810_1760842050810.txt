PR 0.1 — Dual-server dev workflow

Goal: Run client (Vite) + API (Express) together.

Tasks

Add dev scripts & proxy.

Ensure env bootstraps.

Files

package.json (root)

client/vite.config.ts

.env.example

Edits

package.json:

{
  "scripts": {
    "client:dev": "vite",
    "server:dev": "tsx server/index.ts",
    "dev": "concurrently -k -n client,server \"vite\" \"tsx server/index.ts\"",
    "build": "vite build && esbuild server/index.ts --platform=node --packages=external --bundle --format=esm --outdir=dist",
    "start": "NODE_ENV=production node dist/index.js",
    "db:push": "drizzle-kit push"
  },
  "devDependencies": { "concurrently": "^9.0.0" }
}


client/vite.config.ts:

export default defineConfig({
  plugins: [react()],
  server: { proxy: { "/api": "http://localhost:3000" } }
});


.env.example

PORT=3000
DATABASE_URL=postgres://user:pass@host:5432/db
SESSION_SECRET=replace-me


Acceptance

npm run dev opens Vite at :5173 and API at :3000.

Client fetch('/api/*') hits Express via proxy (no CORS errors).

PR 0.2 — Serve SPA in production

Goal: npm run build && npm start serves client/dist + API.

Files

server/index.ts

Edits

import path from "node:path";
import express from "express";

// ... existing middlewares

const clientDist = path.resolve(import.meta.dirname, "../client/dist");
app.use(express.static(clientDist));

// keep API under /api/**
app.get("/env", /* existing */);

// SPA fallback
app.get("*", (_req, res) => {
  res.sendFile(path.join(clientDist, "index.html"));
});


Acceptance

After npm run build && npm start, visiting / loads the SPA; API still works under /env.

Milestone 1 — Database online (Drizzle)
PR 1.1 — Drizzle outdir + push

Goal: Database schema exists in DB; migrations tracked.

Files

drizzle.config.ts

shared/schema.ts (already exists)

new drizzle/ (generated)

Edits

drizzle.config.ts: ensure

export default defineConfig({
  schema: "./shared/schema.ts",
  out: "./drizzle",
  dialect: "postgresql",
  dbCredentials: { url: process.env.DATABASE_URL! }
});


Run:

export DATABASE_URL=...
npx drizzle-kit push


Commit drizzle/ artifacts.

Acceptance

Tables users, projects, tilesets exist.

npm run db:push is repeatable; no errors.

PR 1.2 — DB client and wiring

Goal: A shared Drizzle client that server uses.

Files

server/db.ts (new)

Edits

import { drizzle } from "drizzle-orm/neon-http"; // or pg
import { users, projects, tilesets } from "../shared/schema";
import { neon } from "@neondatabase/serverless";

const sql = neon(process.env.DATABASE_URL!);
export const db = drizzle(sql);

export { users, projects, tilesets };


Acceptance

server/index.ts can import db without crashing on startup (with DATABASE_URL set).

Milestone 2 — Minimal APIs (Tilesets & Projects)
PR 2.1 — Tilesets API (read/write metadata)

Goal: Create/read tileset metadata (image lives in /attached_assets for now).

Files

server/index.ts

server/routes/tilesets.ts (new)

client/src/components/TilesetPanel.tsx (wire to API)

Server

// server/routes/tilesets.ts
import { Router } from "express";
import { db, tilesets } from "../db";
import { eq } from "drizzle-orm";

export const tilesetRouter = Router();

tilesetRouter.get("/", async (_req, res) => {
  const all = await db.select().from(tilesets);
  res.json(all);
});

tilesetRouter.post("/", async (req, res) => {
  const { name, tileSize, spacing, imageUrl, columns, rows } = req.body;
  const [created] = await db.insert(tilesets).values({
    name, tileSize, spacing, imageUrl, columns, rows, createdAt: new Date()
  }).returning();
  res.status(201).json(created);
});

tilesetRouter.get("/:id", async (req, res) => {
  const id = req.params.id;
  const [ts] = await db.select().from(tilesets).where(eq(tilesets.id, id));
  if (!ts) return res.status(404).end();
  res.json(ts);
});


In server/index.ts:

import { tilesetRouter } from "./routes/tilesets";
app.use("/api/tilesets", tilesetRouter);


Client

In TilesetPanel.tsx replace ad-hoc fetches with:

const res = await fetch("/api/tilesets");
const data = await res.json();
// populate panel


Acceptance

GET /api/tilesets returns list.

POST /api/tilesets creates a row; panel shows it.

PR 2.2 — Projects API (persist canvas)

Goal: Save/load project’s canvasState and tileMap.

Files

server/routes/projects.ts (new)

client/src/store/useCanvasStore.ts (persist/load hooks)

client/src/components/ProjectManager.tsx

Server

// server/routes/projects.ts
import { Router } from "express";
import { db, projects } from "../db";
import { eq } from "drizzle-orm";

export const projectsRouter = Router();

projectsRouter.get("/", async (_req, res) => {
  const all = await db.select().from(projects);
  res.json(all);
});

projectsRouter.post("/", async (req, res) => {
  const { name, canvasState, tileMap } = req.body;
  const [created] = await db.insert(projects).values({
    name,
    canvasState: JSON.stringify(canvasState ?? null),
    tileMap: JSON.stringify(tileMap ?? null),
    createdAt: new Date(),
    updatedAt: new Date()
  }).returning();
  res.status(201).json(created);
});

projectsRouter.get("/:id", async (req, res) => {
  const [p] = await db.select().from(projects).where(eq(projects.id, req.params.id));
  if (!p) return res.status(404).end();
  res.json(p);
});

projectsRouter.put("/:id", async (req, res) => {
  const { name, canvasState, tileMap } = req.body;
  const [updated] = await db.update(projects).set({
    name,
    canvasState: JSON.stringify(canvasState ?? null),
    tileMap: JSON.stringify(tileMap ?? null),
    updatedAt: new Date()
  }).where(eq(projects.id, req.params.id)).returning();
  res.json(updated);
});


In server/index.ts:

import { projectsRouter } from "./routes/projects";
app.use("/api/projects", projectsRouter);


Client

useCanvasStore.ts:

Add loadProject(id), saveProject(id).

On save, POST/PUT /api/projects.

ProjectManager.tsx:

“New Project”, “Save Project”, “Open Project” hook into the API.

Acceptance

Create project → reload page → open project restores canvas.

Update project → PUT persists newer canvasState.

Milestone 3 — Tileset ingestion & autotile plumbing
PR 3.1 — Basic tileset ingestion (no upload yet)

Goal: Register existing images (from /attached_assets) as tilesets and compute grid metadata client-side.

Files

client/src/components/TilesetPanel.tsx

client/src/components/Canvas.tsx (if needed)

Tasks

On “Add Tileset”, allow entering imageUrl, tileSize, spacing, infer columns/rows by loading image dimensions on the client, then POST /api/tilesets.

Show computed preview grid overlay in TilesetPanel.

Acceptance

Tilesets create and list with correct columns/rows.

Selecting a tileset enables painting tiles in Canvas (if already implemented).

PR 3.2 — Autotile rules (3×3) integration

Goal: Wire your existing 3×3 rules to operate on tile placements.

Files

client/src/store/useCanvasStore.ts

client/src/components/Canvas.tsx

(optional) client/src/lib/autotile.ts (new helper)

Tasks

When user paints a tile, compute the 3×3 neighborhood and choose the correct edge/corner/center sprite using your rule set.

Maintain a Map<string, TileCell> keyed by x,y,layer,tilesetId.

Expose recomputeNeighbors(x,y) after every placement to avoid stale edges.

Acceptance

Painting areas produces seamless transitions (grass↔water, dirt, etc.).

Repainting updates neighbor edges correctly.

Milestone 4 — Auth (phase 1) & session
PR 4.1 — Session + local login

Goal: Minimal access control for write routes.

Files

server/index.ts (session)

server/auth/local.ts (passport local strategy)

server/routes/auth.ts

Server

import session from "express-session";
import MemoryStore from "memorystore";
const MemStore = MemoryStore(session);

app.use(session({
  secret: process.env.SESSION_SECRET!,
  resave: false,
  saveUninitialized: false,
  store: new MemStore({ checkPeriod: 86400000 })
}));


Implement /api/login, /api/logout, /api/me.

Protect POST/PUT on /api/projects and /api/tilesets with a simple requireAuth middleware.

Acceptance

Login sets a session; write endpoints reject unauthenticated.

Client shows current user from /api/me.

Milestone 5 — Realtime (Yjs) MVP
PR 5.1 — y-websocket server

Goal: Multi-user cursor + shared board state.

Files

server/realtime.ts (new) or separate entry.

client/src/services/collaboration.ts (already exists—attach provider)

Tasks

Add a ws server (or y-websocket npm server). Example (if embedding):

import { WebSocketServer } from "ws";
import setupWSConnection from "y-websocket/bin/utils";
const wss = new WebSocketServer({ noServer: true });

const server = app.listen(port, () => log(...));
server.on("upgrade", (request, socket, head) => {
  if (request.url?.startsWith("/yjs")) {
    wss.handleUpgrade(request, socket, head, ws => {
      setupWSConnection(ws, request, { docName: request.url!.slice(5) });
    });
  } else socket.destroy();
});


Client: connect provider in collaboration.ts and bind to the same doc room.

Acceptance

Open two browsers → see presence; simple shape/tile actions replicate.

Milestone 6 — Quality & polish
PR 6.1 — Lint/format/test baseline

Files

.eslintrc.cjs, .prettierrc, client/vitest.config.ts

Tasks

Add ESLint/Prettier + scripts: "lint", "format".

Add Vitest and 2–3 unit tests (store utils, autotile rules).

Acceptance

npm run lint clean; npm test passes.